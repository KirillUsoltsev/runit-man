## Описание

Простая утилита для управления сервисами [runit](http://smarden.org/runit/ "Домашняя страница runit") через Web-интерфейс, с поддержкой интернационализации.

Сервер запускается скриптом **runit-man**. Примите во внимание, что  **runit-man** обязан иметь привилегии, аналогичные привилегиям процесса **runsvdir**.

## Инсталляция

Обычно вам нужно поставить гемы **runit-man** и **thin** совместно, чтобы эта утилита работала эффективно.
`gem install runit-man thin`

Прагматично установить runit-man как один из сервисов runit, например, так:
`runit-man -p 14500 -r`

Эта команда создаёт сервис runit-man, как один из обычных активных сервисов runit (используя каталоги */etc/sv/* and */etc/service/* по умолчанию).

Подробнее смотрите файл INSTALL.

### Конфигурирование под Rack

Обратите внимание, что гем runit-man gem также предоставляет файл конфигурации Rack config.ru.
Он полезен для запуска runit-man под такими серверами, как unicorn, rainbows и другими. Опция `runit-man --rackup=command` выполняет команду `cd каталог, где лежит config.ru && set environment && exec command`.

## Кастомизация

Эта утилита способна предоставлять дополнительную информацию или действия на своей Web-странице.

### Просмотр имён и содержимого файлов, относящихся к конкретному сервису

Для каждого известного сервиса runit эта утилита просматривает каталог **./runit-man/files-to-view/**.
Каждый симлинк в этом каталоге будет показан как ссылка на просмотр содержимого целевого файла.

### Показ ссылок, относящихся к конкретному сервису

Для каждого известного сервиса runit эта утилита просматривает каталог **./runit-man/urls-to-view/**.
Каждый файл, имеющий расширение .url, будет показан, как сылка на просмотр целевой локации (которая берётся как содержимое файла).

### Показ кнопок, которые посылают сигналы выбранному процессу

Для каждого известного сервиса runit эта утилита просматривает каталог **./runit-man/allowed-signals/**.
Каждый однобуквенно-именованный файл определяет, что кнопка для сигнала должна появиться в пользовательском интерфейсе.

Соответствия между буквами и сигналами перечислены ниже, в секции REST API.

## REST API

### Получение состояния

Вы можете получить текущее состояние сервисов в [формате JSON](http://www.json.org/ "Домашняя страница JSON"), используя
`GET /services.json`

### Управление

Вы можете управлять вашими сервисами, используя
`POST /<service name>/<command>`

Поддерживаемые команды: *up*, *down*, *restart*, *switch_up* (активация сервиса), *switch_down* (деактивация сервиса).

Вы можете также посылать любые сигналы сервису, используя
`POST /<service name>/signal/<signal>`

Поддерживаемые сигналы и их значения:

* t: TERM
* k: KILL
* i: INT
* 1: USR1
* 2: USR2
* a: ALARM
* q: QUIT
* x: EXIT
* p: PAUSE
* c: CONT
* h: HUP
* o: ONCE

### Чтение логов

#### svlogd

Вы можете читать хвост лога сервиса, используя
`GET /<service name>/log/<count of tailing lines>.txt`

Учитывайте, что этот функционал работает, только если Вы логгируете сервис с использованием команды вида 
`exec svlogd options log_directory_location`

#### logger

Если Вы предпочитаете logger, используйте его вот так:
`exec logger -i -t "runit-man" -p local1.info`

При этом нужно использовать опцию -l "logger:/var/log/", где после двоеточия надо указывать базовый каталог логов.

